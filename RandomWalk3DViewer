import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.List;

public class RandomWalk3DViewer extends JPanel
        implements MouseListener, MouseMotionListener, MouseWheelListener {

    private final List<RandomWormGenerator> generators;
    private final List<Color> colors;

    // Camera rotation
    private double camYaw = 0.0;
    private double camPitch = Math.toRadians(20);
    private double zoom = 3.0;

    // Camera pan (screen-space)
    private double panX = 0.0;
    private double panY = 0.0;

    // World-space pivot for orbiting
    private Vector3 pivot = new Vector3(0, 0, 0);

    private int lastMouseX;
    private int lastMouseY;
    private boolean dragging = false;
    private int dragButton = MouseEvent.NOBUTTON;
    private boolean shiftDrag = false;

    public RandomWalk3DViewer(List<RandomWormGenerator> generators, List<Color> colors) {
        this.generators = generators;
        this.colors = colors;

        setBackground(Color.BLACK);
        addMouseListener(this);
        addMouseMotionListener(this);
        addMouseWheelListener(this);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (generators == null || generators.isEmpty()) return;

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(
                RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON
        );

        int w = getWidth();
        int h = getHeight();

        drawAxis(g2, w, h);

        // Draw each worm with its own color
        for (int wIndex = 0; wIndex < generators.size(); wIndex++) {
            RandomWormGenerator gen = generators.get(wIndex);
            List<Vector3> points = gen.getPoints();
            List<Double> sizes   = gen.getSegmentSizes();
            WormSettings settings = gen.getSettings();

            if (points == null || points.size() < 2) continue;

            Color col = (wIndex < colors.size()) ? colors.get(wIndex) : Color.CYAN;

            for (int i = 1; i < points.size(); i++) {
                Vector3 vPrev = points.get(i - 1);
                Vector3 vCur  = points.get(i);

                Point pPrev = projectToScreen(vPrev, w, h);
                Point pCur  = projectToScreen(vCur,  w, h);

                if (pPrev == null || pCur == null) continue;

                double segSize = (i - 1 < sizes.size())
                        ? sizes.get(i - 1)
                        : settings.fixedSegmentSize;

                float thickness = computeStrokeWidth(segSize, settings);

                g2.setStroke(new BasicStroke(
                        thickness,
                        BasicStroke.CAP_ROUND,
                        BasicStroke.JOIN_ROUND
                ));
                g2.setColor(col);
                g2.drawLine(pPrev.x, pPrev.y, pCur.x, pCur.y);
            }
        }
    }

    private float computeStrokeWidth(double segSize, WormSettings settings) {
        double minS = settings.minSegmentSize;
        double maxS = settings.maxSegmentSize;

        if (maxS <= minS + 1e-6) {
            return 3.0f;
        }
        double t = (segSize - minS) / (maxS - minS);
        t = clamp(t, 0.0, 1.0);
        double width = 1.0 + t * 6.0; // 1 to 7
        return (float) width;
    }

    private double clamp(double v, double min, double max) {
        return Math.max(min, Math.min(max, v));
    }

    private Point projectToScreen(Vector3 v, int width, int height) {
        // Translate so that pivot is the rotation center in world space
        double wx = v.x - pivot.x;
        double wy = v.y - pivot.y;
        double wz = v.z - pivot.z;

        // Rotate around Y (yaw)
        double cosY = Math.cos(camYaw);
        double sinY = Math.sin(camYaw);
        double x1 = cosY * wx + sinY * wz;
        double z1 = -sinY * wx + cosY * wz;

        // Rotate around X (pitch)
        double cosX = Math.cos(camPitch);
        double sinX = Math.sin(camPitch);
        double y1 = cosX * wy - sinX * z1;
        double z2 = sinX * wy + cosX * z1;

        double cameraDistance = 200.0;
        double denom = cameraDistance + z2;
        if (denom <= 0.1) {
            return null;
        }

        double factor = cameraDistance / denom;

        int centerX = (int) (width  / 2.0 + panX);
        int centerY = (int) (height / 2.0 + panY);

        int screenX = (int) (centerX + x1 * factor * zoom);
        int screenY = (int) (centerY - y1 * factor * zoom);

        return new Point(screenX, screenY);
    }

    private void drawAxis(Graphics2D g2, int w, int h) {
        Vector3 origin = new Vector3(0, 0, 0);
        Vector3 xAxis  = new Vector3(50, 0, 0);
        Vector3 yAxis  = new Vector3(0, 50, 0);
        Vector3 zAxis  = new Vector3(0, 0, 50);

        Point o = projectToScreen(origin, w, h);
        Point x = projectToScreen(xAxis,  w, h);
        Point y = projectToScreen(yAxis,  w, h);
        Point z = projectToScreen(zAxis,  w, h);

        if (o == null) return;

        g2.setStroke(new BasicStroke(1.5f));

        if (x != null) {
            g2.setColor(Color.RED);
            g2.drawLine(o.x, o.y, x.x, x.y);
            g2.drawString("X", x.x + 5, x.y);
        }
        if (y != null) {
            g2.setColor(Color.GREEN);
            g2.drawLine(o.x, o.y, y.x, y.y);
            g2.drawString("Y", y.x + 5, y.y);
        }
        if (z != null) {
            g2.setColor(Color.BLUE);
            g2.drawLine(o.x, o.y, z.x, z.y);
            g2.drawString("Z", z.x + 5, z.y);
        }
    }

    // ===== Mouse controls =====

    @Override
    public void mousePressed(MouseEvent e) {
        dragging = true;
        dragButton = e.getButton();
        shiftDrag  = e.isShiftDown();
        lastMouseX = e.getX();
        lastMouseY = e.getY();

        if (shiftDrag) {
            // Shift+click: choose a new world-space pivot based on what you clicked
            Vector3 newPivot = findClosestWorldPointToScreen(e.getX(), e.getY());
            if (newPivot != null) {
                pivot = newPivot;
                repaint();
            }
        }
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        dragging = false;
        dragButton = MouseEvent.NOBUTTON;
        shiftDrag = false;
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        if (!dragging) return;

        int x = e.getX();
        int y = e.getY();

        int dx = x - lastMouseX;
        int dy = y - lastMouseY;

        if (shiftDrag) {
            // Shift + any button: rotate (orbit) around the current pivot
            double sensitivity = 0.01;
            camYaw   += dx * sensitivity;
            camPitch += dy * sensitivity;

            double maxPitch = Math.PI / 2 - 0.1;
            if (camPitch > maxPitch) camPitch = maxPitch;
            if (camPitch < -maxPitch) camPitch = -maxPitch;
        } else {
            if (dragButton == MouseEvent.BUTTON1) {
                // Left drag: rotate around pivot
                double sensitivity = 0.01;
                camYaw   += dx * sensitivity;
                camPitch += dy * sensitivity;

                double maxPitch = Math.PI / 2 - 0.1;
                if (camPitch > maxPitch) camPitch = maxPitch;
                if (camPitch < -maxPitch) camPitch = -maxPitch;
            } else if (dragButton == MouseEvent.BUTTON3) {
                // Right drag: pan
                double panSensitivity = 1.0;
                panX += dx * panSensitivity;
                panY += dy * panSensitivity;
            }
        }

        lastMouseX = x;
        lastMouseY = y;

        repaint();
    }

    @Override
    public void mouseWheelMoved(MouseWheelEvent e) {
        int notches = e.getWheelRotation();
        zoom *= (1 - notches * 0.1);
        if (zoom < 0.5) zoom = 0.5;
        if (zoom > 20.0) zoom = 20.0;
        repaint();
    }

    // ===== Helper: pick world-space pivot from click =====

    private Vector3 findClosestWorldPointToScreen(int mouseX, int mouseY) {
        if (generators == null || generators.isEmpty()) return null;

        int w = getWidth();
        int h = getHeight();

        double bestDist2 = Double.MAX_VALUE;
        Vector3 best = null;

        for (RandomWormGenerator gen : generators) {
            List<Vector3> pts = gen.getPoints();
            if (pts == null) continue;

            for (Vector3 v : pts) {
                Point p = projectToScreen(v, w, h);
                if (p == null) continue;

                double dx = mouseX - p.x;
                double dy = mouseY - p.y;
                double d2 = dx * dx + dy * dy;

                if (d2 < bestDist2) {
                    bestDist2 = d2;
                    best = v;
                }
            }
        }

        return best;
    }

    // Unused but required
    @Override public void mouseMoved(MouseEvent e) {}
    @Override public void mouseClicked(MouseEvent e) {}
    @Override public void mouseEntered(MouseEvent e) {}
    @Override public void mouseExited(MouseEvent e) {}
}
